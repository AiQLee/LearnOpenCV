////opencv
//#include <opencv2/core/core.hpp>
//#include <opencv2/highgui/highgui.hpp>
//#include <opencv2/video/background_segm.hpp>
//#include <opencv2/bgsegm.hpp>
////C++
//#include <iostream>
//#include <sstream>
//
//using namespace std;
//using namespace cv;
//
////global variables
//Mat frame; //current frame
//Mat fgMaskMOG; //fg mask generated by MOG method
//Mat fgMaskMOG2, fgMaskMOG2_copy; //fg mask fg mask generated by MOG2 method
//Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
//int keyboard;
//
////閾値(threshold)の設定
//static const int threshhold = 10;
//
////変数の準備
//cv::Mat im1, im2, im3;
//cv::Mat d1, d2, diff;
//cv::Mat im_mask, mask;
//
////function declarations
//void help();
//void processVideo(char* videoFilename);
//int diffDetection(char* videoFilename);
//
//void help() {
//	cout
//	<< "AiQLee"
//	<< endl;
//}
//
//int main() {
//	help();
//
//	char* videoAddr = "video_input/stabilized_video_param800.avi";
//	processVideo(videoAddr);
//	//diffDetection(videoAddr);
//
//	destroyAllWindows();
//	return EXIT_SUCCESS;
//}
//
//void processVideo(char* videoFilename) {
//	namedWindow("Frame");
//	namedWindow("FG Mask MOG");
//	namedWindow("FG Mask MOG 2");
//
//	//Length of histroy
//	//and the threshhold of detecting 
//	//and true of false of detecting shadow
//	//pMOG = createBackgroundSubtractorMOG(200, 5, 0.7, 0);
//	pMOG = createBackgroundSubtractorMOG2(500, 5, true);
//	//pMOG = createBackgroundSubtractorMOG2();
//	
//	//pMOG2 = createBackgroundSubtractorMOG2(20, 16, true);
//	pMOG2 = createBackgroundSubtractorMOG2(500, 100, true); //MOG2 approach
//	//pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
//
//	//create the capture object
//	//VideoCapture cap(0);
//	VideoCapture cap(videoFilename);
//	if (!cap.isOpened()) {
//		//error in opening the video input
//		cerr << "Unable to open video file: " << videoFilename << endl;
//		exit(EXIT_FAILURE);
//	}
//	//read input data. ESC or 'q' for quitting
//	while ((char)keyboard != 'q' && (char)keyboard != 27) {
//		//read the current frame
//		if (!cap.read(frame)) {
//			cerr << "Unable to read next frame." << endl;
//			cerr << "Exiting..." << endl;
//			exit(EXIT_FAILURE);
//		}
//		//resize the image to 1/2 size
//		//cv::Mat	rawImage = cv::Mat(frame.rows/2, frame.cols/2, CV_8UC3);
//		cv::Mat	rawImage = cv::Mat(frame.rows/2, frame.cols/2, CV_8UC3);
//		cv::resize(frame, rawImage, rawImage.size());
//		
//		//update the background model
//		//The last parameter represent the speed of Background updating
//		// from 0 to 1 , the bigger the faster 
//		// 0 no update
//		// negative num means auto update
//		//pMOG->apply(frame, fgMaskMOG);
//		pMOG2->apply(rawImage, fgMaskMOG2, 0.01);
//		pMOG->apply(rawImage, fgMaskMOG2_copy, 0.01);
//		//pMOG2->apply(rawImage, fgMaskMOG);
//
//		//get the frame number and write it on the current frame
//		stringstream ss;
//		rectangle(rawImage, cv::Point(10, 2), cv::Point(100, 20),
//			cv::Scalar(255, 255, 255), -1);
//		ss << cap.get(CAP_PROP_POS_FRAMES);
//		string frameNumberString = ss.str();
//		putText(rawImage, frameNumberString.c_str(), cv::Point(15, 15),
//			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
//
//
//		erode(fgMaskMOG2, fgMaskMOG2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//		dilate(fgMaskMOG2, fgMaskMOG2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//
//
//		//erode(fgMaskMOG2_copy, fgMaskMOG2_copy, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//		//dilate(fgMaskMOG2_copy, fgMaskMOG2_copy, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//
//		//////morphological closing (removes small holes from the foreground)
//		//dilate(fgMaskMOG2, fgMaskMOG2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//		//erode(fgMaskMOG2, fgMaskMOG2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//
//
//
//
//		//show the current frame and the fg masks
//		imshow("Frame", rawImage);
//		//imshow("FG Mask MOG", fgMaskMOG);
//		imshow("FG Mask MOG 2", fgMaskMOG2);
//		//imshow("FG Mask MOG 2 COPY", fgMaskMOG2_copy);
//		//get the input from the keyboard
//		keyboard = waitKey(30);
//	}
//	//delete capture object
//	cap.release();
//}
//
//
//int diffDetection(char* videoFilename)
//{
//	//カメラを開く
//	cv::VideoCapture cap(videoFilename);
//	//cv::VideoCapture cap(0);
//	//カメラが開けたか確認
//	if (!cap.isOpened()) {
//		cout << "hello" << endl;
//		return -1;
//	}
//
//	cout << "program starts" << endl;
//
//	//ウィンドウを2枚生成
//	cv::namedWindow("in");
//	cv::namedWindow("out");
//	//カメラから3フレーム取り出す
//	if (!cap.read(frame)) {
//		cerr << "Unable to read next frame." << endl;
//		exit(EXIT_FAILURE);
//	}
//	cv::cvtColor(frame, im1, CV_RGB2GRAY);
//	if (!cap.read(frame)) {
//		cerr << "Unable to read next frame." << endl;
//		exit(EXIT_FAILURE);
//	}
//	cv::cvtColor(frame, im2, CV_RGB2GRAY);
//	if (!cap.read(frame)) {
//		cerr << "Unable to read next frame." << endl;
//		exit(EXIT_FAILURE);
//	}
//	cv::cvtColor(frame, im3, CV_RGB2GRAY);
//
//	while (1)
//	{
//
//	
//
//		//差分1：フレーム1と2の差を求める
//		cv::absdiff(im1, im2, d1);
//		//差分2：フレーム2と3の差を求める
//		cv::absdiff(im2, im3, d2);
//		//差分1と差分2の結果を比較(論理積)し、diffに出力
//		cv::bitwise_and(d1, d2, diff);
//
//		//差分diffのうち、閾値thを超えている部分を1、それ以外を0としてmaskに出力
//		cv::threshold(diff, mask, threshhold, 1, cv::THRESH_BINARY);
//		//マスクmaskのうち、1(True)の部分を白(0)に、0(False)の部分を黒(255)にしてim_maskに出力
//		cv::threshold(mask, im_mask, 0, 255, cv::THRESH_BINARY);
//		//メディアンフィルタを使った平滑化によってゴマ塩ノイズを除去、アパーチャサイズ5
//		cv::medianBlur(im_mask, im_mask, 5);
//
//
//		//erode(im_mask, im_mask, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//		//dilate(im_mask, im_mask, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
//
//
//		//cv::Mat	rawImage = cv::Mat(frame.rows/2, frame.cols/2, CV_8UC3);
//		cv::Mat	rawImage = cv::Mat(frame.rows/2, frame.cols/2, CV_8UC3);
//		cv::resize(frame, rawImage, rawImage.size());
//		cv::Mat	resultImage = cv::Mat(im_mask.rows/2, im_mask.cols/2, CV_8UC3);
//		cv::resize(im_mask, resultImage, resultImage.size());
//
//		stringstream ss;
//		rectangle(rawImage, cv::Point(10, 2), cv::Point(100, 20),
//			cv::Scalar(255, 255, 255), -1);
//		ss << cap.get(CAP_PROP_POS_FRAMES);
//		string frameNumberString = ss.str();
//		putText(rawImage, frameNumberString.c_str(), cv::Point(15, 15),
//			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
//
//
//		//ウィンドウ2枚にそれぞれ入力画像、差分画像を表示
//		cv::imshow("in", rawImage);
//		//if(stoi(frameNumberString)>500)
//		cv::imshow("out", resultImage);
//
//		//新しいフレームをカメラから一つ取り出し、3つのフレームを全てずらす
//		im2.copyTo(im1, im2);
//		im3.copyTo(im2, im3);
//		if (!cap.read(frame)) {
//			cerr << "Unable to read next frame." << endl;
//			exit(EXIT_FAILURE);
//		}
//		cv::cvtColor(frame, im3, CV_RGB2GRAY);
//
//		//ウィンドウ上でEscキーが押されたらプログラム終了
//		if (cv::waitKey(27) >= 0)
//		{
//			cv::destroyAllWindows();
//			break;
//		}
//	}
//
//	cap.release();
//}